// Source: https://usaco.guide/general/io

#include <bits/stdc++.h>
//treat tree as bipartite graph
//each move goes from a node of type 0 to a node of type 1(or vice versa)
//difference between the sums of the two groups is constant (after 1st move)
using namespace std;

int main() {
	int N;
    cin >> N;
    int type[N+1], values[N+1];
    vector<vector<int>> adj(N+1); 
    for (int i=1;i<=N;i++){
        cin >> values[i];
    }
    for (int i=1;i<=N-1;i++){
        int a, b;
        //linking two nodes
        cin >> a >> b;
        adj[a].push_back(b);
        adj[b].push_back(a);
    }
    //assign bipartite;
    deque<pair<int, int>> frontier;
    frontier.push_back({1,0}); //start with first node assigned with type 0
    bool vis[N+1] = {false};
    while (!frontier.empty()){
        if (vis[frontier.front().first]){
            frontier.pop_front();
        }else{
            vis[frontier.front().first] = true;
            type[frontier.front().first] = frontier.front().second;
            for (auto const element: adj[frontier.front().first]){
                //if its a new element
                if (!vis[element]){
                    frontier.push_back({element, abs(1-frontier.front().second)});
                }
            }
            frontier.pop_front();
        }
    }
    //sum of the two groups (type 0 and type 1) as well as size
    int g0=0, g1=0, g0size=0, g1size=0;
    for (int i=1;i<=N;i++){
        if (type[i]==0){
            g0+=values[i];
            g0size++;
        }else{
            g1+=values[i];
            g1size++;
        }
    }
    if (g0%(12) - g1%(12) == 0){
        cout << N;
    }else{
        if (g0%(12) == (g1+1)%(12)){ //if g0 leads at the start, you must start on a type 0 node
            cout << g0size;
            return 0;
        }
        if (g1%(12) == (g0+1)%(12)){ //similar logic
            cout << g1size;
            return 0;
        }
        //no sollutions otherwise 
        cout << 0;
        return 0;
    }

}
